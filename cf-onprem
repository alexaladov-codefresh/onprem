#!/usr/bin/env bash
#

#set -x

msg() { echo -e "\e[32mINFO [$(date +%F\ %T)] ---> $1\e[0m"; }
warning() { echo -e "\e[33mWARNING [$(date +%F\ %T)] ---> $1\e[0m"; }
err() { echo -e "\e[31mERR [$(date +%F\ %T)] ---> $1\e[0m" ; exit 1; }

if [ -f "./env-vars" ]; then
. ./env-vars
fi

readonly HELM_VERSION="${CF_HELM_VERSION:-2.10.0}"
readonly CHANNEL="${CF_HELM_CHANNEL:-dev}"
readonly CODEFRESH_REPOSITORY=http://charts.codefresh.io/${CHANNEL}

#export KUBECONFIG=./.kube/config

readonly WORKING_DIR="$(dirname "$0")"
readonly SERVICE_ACCOUNT="${WORKING_DIR}/sa.json"
readonly VALUES_FILE="${WORKING_DIR}/values.yaml"
readonly DOCKER_CFG_YAML="${WORKING_DIR}/dockercfg.yaml"
#readonly SECRET_VALUES_FILE="${WORKING_DIR}/values-dec.yaml"
readonly WEBTLS_VALUES_FILE="${WORKING_DIR}/webtls.yaml"

usage() {
	echo "sudo $0 [-h] [-y|--yes]"
	exit 0
}

check() { command -v $1 >/dev/null 2>&1 || err "$1 binary is required!"; }

ver() { printf "%03d%03d%03d%03d" $(echo "$1" | tr '.' ' '); }

exists() {
	if command -v $1 >/dev/null 2>&1; then
		msg "$1 binary installed"
	else
		warning "Please install $1 to proceed"
		exit 1
	fi
}

run_as_root() {
	if [[ $EUID > 0 ]]; then
		err "Please run as root/sudo"
		exit 1
	fi
}

approveContext() {
	msg "Your kubectl is configured with the following context: "
	kubectl config current-context
	read -r -p "Are you sure you want to continue? [y/N] " response

	if [[ "$response" =~ ^([yY][eE][sS]|[yY])+$ ]]
	then
			msg "No problem, continuing with the script..."
	else
			msg "Exiting..."
			exit 0
	fi
}

checkHelmInstalled() {
  if command -v $1 >/dev/null 2>&1; then
    helm_version=$(helm version --client --short | sed 's/.*\: v//' | sed 's/+.*//')
    msg "helm is already installed and has version v$helm_version"
    [ $(ver $helm_version) -lt $(ver $HELM_VERSION) ] && \
    err "You have older helm version than required. Please upgrade to v$HELM_VERSION or newer !"
  else
    warning "helm is not installed"
    if [[ ! "$YES" == 'true' ]]; then
    read -p "Do you want to install helm ? [y/n] " yn
      case ${yn} in
        y|Y)
          helmInstall
      ;;
        *)
          err "Need helm to deploy Codefresh app ! Exiting..."
          #exit 1
      ;;
      esac
    else
      helmInstall
    fi
  fi
}

helmInstall() {
  msg "Downloading and installing helm..."
<< ////
  case "$(uname -s)" in
    Linux)
      os=linux
    ;;
    Darwin)
      os=darwin
    ;;
    *)
    ;;
  esac
////
  wget https://storage.googleapis.com/kubernetes-helm/helm-v${HELM_VERSION}-${os}-amd64.tar.gz -P /tmp/
  tar xvf /tmp/helm-v${HELM_VERSION}-${os}-amd64.tar.gz -C /tmp/
  chmod +x /tmp/${os}-amd64/helm
  sudo mv /tmp/${os}-amd64/helm /usr/local/bin/
  rm -rf /tmp/helm-v${HELM_VERSION}-${os}-amd64 /tmp/helm-v${HELM_VERSION}-${os}-amd64.tar.gz
}

checkTillerInstalled() {
  status=$(kubectl -nkube-system get pod -l app=helm -l name=tiller -o=go-template --template='{{  range $i, $v := .items }}{{ if eq $v.status.phase "Running" }}{{ $v.status.phase }}{{ end }}{{ end }}')
  if [ "$status" == "Running" ]; then
    msg "Tiller is installed and running"
    helm init -c
    helm_version=$(helm version --client --short | sed 's/.*\: v//' | sed 's/+.*//')
    tiller_version=$(helm version --server --short | sed 's/.*\: v//' | sed 's/+.*//')
    if [[ ! "$YES" == 'true' ]] && [ $(ver $tiller_version) -lt $(ver $helm_version) ]; then
      warning "You're running helm v$helm_version but tiller has v$tiller_version."
      read -p  " Do you want to upgrade tiller to v$helm_version ? [y/n] " yn
      case ${yn} in
        y|Y)
          kubectl create -f ./tiller-rbac-config.yaml > /dev/null 2>&1
          helm init --upgrade --service-account tiller --wait
      ;;
        *)
          err "You need to upgrade tiller ! Exiting..."
      ;;
      esac
    fi
    if [[ "$YES" == 'true' ]] && [ $(ver $tiller_version) -lt $(ver $helm_version) ]; then
      err "You're running helm v$helm_version but tiller has v$tiller_version . You need to upgrade tiller ! Exiting..."
    fi
  else
    warning "Unable to determine tiller at its default location."
    if [[ ! "$YES" == 'true' ]]; then
      read -p  " Do you want to deploy tiller ? [y/n] " yn
      case ${yn} in
        y|Y)
          kubectl create -f ./tiller-rbac-config.yaml
          helm init --service-account tiller --wait
      ;;
        *)
          err "Need to deploy tiller ! Exiting..."
          exit 1
      ;;
      esac
    else
      kubectl create -f ./tiller-rbac-config.yaml
      helm init --service-account tiller --wait
    fi
  fi

}

checkTillerStatus() {
	while true; do
    status=$(kubectl -nkube-system get pod -l app=helm -l name=tiller -o=go-template --template='{{  range $i, $v := .items }}{{ if eq $v.status.phase "Running" }}{{ $v.status.phase }}{{ end }}{{ end }}')

	  msg "Tiller status = $status"
	  [ "$status" == "Running" ] && break

	  msg "Sleeping 5 seconds ..."
	  sleep 5

	done
}

generateWebTlsValuesFile() {

WEBTLSKEY=$(cat ${WebTlsKey} | sed 's/^/    /')
WEBTLSCERT=$(cat ${WebTlsCert} | sed 's/^/    /')

WEBTLSKEY_CFUI=$(cat ${WebTlsKey} | sed 's/^/      /')
WEBTLSCERT_CFUI=$(cat ${WebTlsCert} | sed 's/^/      /')

cat <<-EOF >${WEBTLS_VALUES_FILE}
---
webTLS:
  key: |
${WEBTLSKEY}
  cert: |
${WEBTLSCERT}

cfui:
  webTLS:
    key: |
${WEBTLSKEY_CFUI}
    cert: |
${WEBTLSCERT_CFUI}
EOF
#  echo "Success!"
#  exit 0
}

[ "$1" == "-h" ] && usage

# run_as_root

while [[ $1 =~ ^(-(y)|--(yes|web-tls-key|web-tls-cert)) ]]
do
  key=$1
  value=$2
  case $key in
    -y|--yes)
        YES="true"
      ;;
    --web-tls-key)
        WebTlsKey="$value"
        shift
      ;;
    --web-tls-cert)
        WebTlsCert="$value"
        shift
      ;;
  esac
  shift # past argument or value
done

os=

case "$(uname -s)" in
  Linux)
    os=linux
  ;;
  Darwin)
    os=darwin
  ;;
  *)
  ;;
esac

msg "Starting on-prem Codefresh deployment"

if [[ ! "$YES" == 'true' ]]; then
  approveContext
else
  msg "Your kubectl is configured with the following context: "
	kubectl config current-context
fi

#if [ -n "${WebTlsKey}" ] && [ -z "${WebTlsCert}" ]; then
#if [ -z "${WebTlsKey}" ] && [ -n "${WebTlsCert}" ]; then
[ -n "${WebTlsKey}" ] && [ -z "${WebTlsCert}" ] && err "Please specify --web-tls-cert argument"
[ -n "${WebTlsKey}" ] && [ ! -f "${WebTlsKey}" ] && err "${WebTlsKey} file path not found. Please define correct path to the private key file."
[ -z "${WebTlsKey}" ] && [ -n "${WebTlsCert}" ] && err "Please specify --web-tls-key argument"
[ -n "${WebTlsCert}" ] && [ ! -f "${WebTlsCert}" ] && err "${WebTlsCert} file path not found. Please define correct path to the certificate full chain file."
[ -n "${WebTlsKey}" ] && [ -f "${WebTlsKey}" ] && [ -n "${WebTlsCert}" ] && [ -f "${WebTlsCert}" ] && generateWebTlsValuesFile

msg "Checking helm binary on your system"
checkHelmInstalled "helm"

msg "Checking if tiller is installed on kubernetes cluster"
checkTillerInstalled

msg "Checking tiller status..."
checkTillerStatus

msg "Adding Helm repo..."
#addHelmCodefreshRepo
helm repo add codefresh-onprem-${CHANNEL} "${CODEFRESH_REPOSITORY}"

DOCKER_CFG_JSON=$(cat ${SERVICE_ACCOUNT})

if [ $os == "linux" ]; then
  BASE64="base64 -w0"
else
  BASE64="base64"
fi

DOCKER_CFG_VAR=$(echo -n "_json_key:${DOCKER_CFG_JSON}" | $BASE64)

cat <<EOF >${DOCKER_CFG_YAML}
---
dockerconfigjson:
  auths:
    gcr.io:
      auth: ${DOCKER_CFG_VAR}

cfui:
  dockerconfigjson:
    auths:
      gcr.io:
        auth: ${DOCKER_CFG_VAR}

runtime-environment-manager:
  dockerconfigjson:
    auths:
      gcr.io:
        auth: ${DOCKER_CFG_VAR}

onboarding-status:
  dockerconfigjson:
    auths:
      gcr.io:
        auth: ${DOCKER_CFG_VAR}
EOF

#MTU_VALUE="--set global.mtu=$(cat /sys/class/net/cni0/mtu)"
#TIMESTAMP=$(date +%F_%H-%M-%S)
# --values "${SECRET_VALUES_FILE}" \
#  --version 0.6.62 \
#  --force \

[ -n "${WebTlsKey}" ] && [ -f "${WebTlsKey}" ] && [ -n "${WebTlsCert}" ] && [ -f "${WebTlsCert}" ] && [ -f "${WEBTLS_VALUES_FILE}" ] && WEBTLS_VALUES="--values ${WEBTLS_VALUES_FILE}"

msg "Installing/Updating Codefresh..."
helm upgrade cf codefresh-onprem-${CHANNEL}/codefresh \
  --install \
  --namespace codefresh \
  --values "${VALUES_FILE}" \
  --values "${DOCKER_CFG_YAML}" \
  ${WEBTLS_VALUES} \
  --no-hooks \
  --set cfapi.redeploy=true \
  ${MTU_VALUE}
